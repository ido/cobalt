#!/usr/bin/env python
# Copyright 2017 UChicago Argonne, LLC. All rights reserved.
# Licensed under a modified BSD 3-clause license. See LICENSE for details.
''' anaylize the PBS-style log generated by Qsim'''

import sys
import time
from datetime import datetime

__helpmsg__ = "Usage: qsim <PBS-log-file-path>"

begin_time = 0
TOTAL_NODES = 40960

def parseline(line):
    '''parse a line in work load file, return a temp
    dictionary with parsed fields in the line'''
    temp = {}
    firstparse = line.split(';')
    eventType = firstparse[1]
    temp['EventType'] = firstparse[1]
    temp['datetime'] = firstparse[0]
    temp['jobid'] = firstparse[2]
    substr = firstparse.pop()
    if len(substr) > 0:
        secondparse = substr.split(' ')
        for item in secondparse:
            tup = item.partition('=')
            if not temp.has_key(tup[0]):
                temp[tup[0]] = tup[2]
    return temp

def find_not_sched_jobs(E_jobs, Q_jobs):
    missingJobs = []
    for qjob in Q_jobs:
        id = qjob['jobid']
        found = False
        for ejob in E_jobs:
            if id == ejob['jobid']:
                found = True
                break
        if found == False:
            missingJobs.append(qjob)
    return missingJobs

def max(a, b):
    if a >= b:
        return a
    else:
        return b

def min(a, b):
    if a <= b:
        return a
    else:
        return b

def sec_to_date(sec, format="%m/%d/%Y %H:%M:%S"):
    tmp = datetime.fromtimestamp(sec)
    fmtdate = tmp.strftime(format)
    return fmtdate    
                      
def date_to_sec(fmtdate, format="%m/%d/%Y %H:%M:%S"):
    t_tuple = time.strptime(fmtdate, format)
    sec = time.mktime(t_tuple)
    return sec

if __name__ == '__main__':
    
    if len(sys.argv) == 1:
        print __helpmsg__
        sys.exit(1)
    
    if sys.argv[1]:
        LOG_PATH = sys.argv[1]
        
    print LOG_PATH
    
    E_jobs = []
    F_jobs = []
    Q_jobs = []
    S_jobs = []
    
    temp = {'jobid':'*', 'submittime':'*', 'queue':'*', 
            'Resource_List.walltime':'*','nodes':'*', 'runtime':'*'}
    # raw_job_dict = { '<jobid>':temp, '<jobid2>':temp2, ...}
    raw_job_dict = {}
    wlf = open(LOG_PATH, 'r')
    for line in wlf:
        if line[0].isdigit():
            line = line.strip('\n')
            temp = parseline(line)
            eType = temp['EventType']
            
            if eType == 'Q':
                Q_jobs.append(temp)
            elif eType == 'S':
                S_jobs.append(temp)
            elif eType == 'E':
                E_jobs.append(temp)
            elif eType == 'F':
                F_jobs.append(temp)
            else:
                #print "invalid event type:", eType
                pass
    
    total_Q_job = len(Q_jobs)
    total_E_job = len(E_jobs)
    total_S_job = len(S_jobs)
    total_F_job = len(F_jobs)
    
    end_node_hour = 0
    fail_node_hour = 0   
    total_waiting_time = 0
    total_response_time = 0
    total_slowdown = 0
    total_runtime = 0
    node_time_st = 0
    total_period =  date_to_sec(E_jobs[len(E_jobs)-1].get('datetime')) - date_to_sec(Q_jobs[0].get('datetime'))
    TN = total_period * TOTAL_NODES
    
    waiting_times  = []
    resp_times = []
    slowdowns = []
    run_times = []
    
    max_resp_time = 0
    max_slowdown = 0
    max_run_time = 0
    
    for spec in E_jobs:
        wait_time = float(spec['start']) - float(spec['qtime'])
        waiting_times.append(wait_time)
                
        response_time =  float(spec['end']) - float(spec['qtime'])
        resp_times.append(response_time)
        
        runtime = float(spec['end']) - float(spec['start'])
        run_times.append(runtime)
        
        slowdown =  round(max(response_time, 10) / max(runtime, 10.0), 2)
        slowdowns.append(slowdown)
            
        node_time_st += int(spec['Resource_List.ncpus']) * runtime
        
        if response_time > max_resp_time:
            max_resp_time = response_time
            max_resp_job = spec['jobid'] 
        if slowdown > max_slowdown:
            max_slowdown = slowdown
            max_slowdown_job = spec['jobid']
        if runtime > max_run_time:
            max_run_time = runtime
            max_runtime_job = spec['jobid']
    
    slowdowns.sort()
    resp_times.sort()
    waiting_times.sort()
    run_times.sort()
#    for i in range(0,3):
#        slowdowns.pop()
#        slowdowns.pop(0)
#        max_wait_time = waiting_times.pop()
#        waiting_times.pop(0)
#        resp_times.pop()
#        resp_times.pop(0)
            
    for number in slowdowns:
        total_slowdown += number
        
    for number in waiting_times:
        total_waiting_time += number
        
    for number in resp_times:
        total_response_time += number
        
    for number in run_times:
        total_runtime += number    

    for spec in F_jobs:
        fail_node_hour += int(spec['Resource_List.ncpus']) * float(spec['failtime'])
            
    ave_waiting_time = total_waiting_time / total_E_job
    ave_response_time = total_response_time / total_E_job
    ave_slowdown = total_slowdown / len(slowdowns)
    ave_runtime = total_runtime / len(run_times)
    
    utilization = node_time_st / TN

    end_node_hour = node_time_st / 3600 
    fail_node_hour /= 3600
    total_node_hour = end_node_hour + fail_node_hour
    
    print "the time stamp of first job submitted: ", Q_jobs[0].get('datetime')
    print "the time stamp of last job end: ", E_jobs[len(E_jobs)-1].get('datetime') 
    print "total Queued jobs: ", total_Q_job
    print "total Completed jobs: ", total_E_job
    print "total started job*time", total_S_job
    print "total failures:", total_F_job
    if total_F_job > 0:
        print "MTBF(hour):", total_period / (total_F_job * 3600)
    print "average waiting time(sec): ", ave_waiting_time
    print "average response time(sec): ", ave_response_time
    print "average running time(sec): ", ave_runtime    
    print "average bounded slowdown:", ave_slowdown
    print "utilization:", utilization
    
    print "max waiting time(sec): ", waiting_times[len(waiting_times)-1]
    print "max response time(sec): ", max_resp_time
    print "max running time(sec): ", max_run_time

    print "valid node-hour(node*hour)", end_node_hour
    print "waste node-hour(node*hour)", fail_node_hour
    print "total node-hour(node*hour)", end_node_hour + fail_node_hour
    
    missJobs = find_not_sched_jobs(S_jobs, Q_jobs)
            
    print "job not scheduled: ", len(missJobs)
    for job in missJobs:
        print job

    noendJob = find_not_sched_jobs(E_jobs, S_jobs)
    
    print "job started but not ended: ", len(noendJob)
    if len(noendJob) > 0:
        for job in noendJob:
            print job
